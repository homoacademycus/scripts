user  nginx; # 워커 프로세스의 사용자권한
pid        /var/run/nginx.pid; # 마스터 프로세스의 ID
error_log  /var/log/nginx/error.log warn; # 로그 모드 warn 또는 debug
worker_processes  1; # 실질적 웹서버 역할. CPU 코어수 고려해야.

events { # 비동기 이벤트 처리 방식

    # 최대 접속자수 = worker_processes 수 x worker_connections 수
    worker_connections  1024; # 하나의 worker 프로세스가 처리할 수 있는 연결 수
    multi_accept on;

}
http { # 여러 server 블록 포함가능

    include     /etc/nginx/mime.types;
    include 	/etc/nginx/conf.d/*.conf;

    default_type  application/octet-stream;
    keepalive_timeout  10; # 연결을 몇초 유지?(default=10) 값이 높으면 불필요한 접속 유지
    #tcp_nopush     on;
    sendfile        on;
    #gzip  on;
    
    access_log  /var/log/nginx/access.log  main;
    log_format  main  '$remote_addr - $remote_user "$request" ';

}
http, server, location {
    
    # HTTP 요청이 전달되는 방식을 POST로 통일
    proxy_method POST; 

    # 요청의 바디, 헤더 정보를 벡앤드 앱서버에 전달할지 여부
    proxy_pass_request_body on;
    proxy_pass_request_headers  on;

    # 업스트림 사용 시, 업스트림 내의 다음 서버에 재전송되는 상황 설정
    proxy_next_upstream error timeout invalid_header http_504 http_404; 

    # 벡엔드 앱서버로부터 응답을 받아서 client에 넘길 때, 보안 상 헤더 정보를 지우는데, 
    # default 항목(Date, Server, X-Pad, X-Accel-*)에 항목을 더 추가
    proxy_hide_header Cache-Control;

    # 응답 리다이렉션 시, 헤더의 URL 재작성
    proxy_redirect http://localhost:80/ http://hostname/;

    # 응답 버퍼링 설정
    proxy_buffering on;
    proxy_buffer_size 4k;
    proxy_buffers 8; # 개수
    proxy_busy_buffers_size 2*proxy_buffer_size; # 지정 용량 초과시, client에 전송

    # 캐시 설정
    proxy_cache cache-zone1;
    proxy_cache_key "$scheme$host$request_uri$cookie_user"; # 동일한 캐시로 인식
    proxy_cache_path 경로 [levels=2 keys_zone=zone1:5k inactive=1m max_size=50k];
    proxy_cache_method POST; # 캐쉬를 적용할 HTTP 메소드
    proxy_cache_valid 404 1m; # 응답코드 별 캐싱시간
    proxy_cache_use_stale error timeout invalid_header http_404; # 상황에 따른 캐시 사용여부

}
location, if {

    # HTTP 요청을 어느 서버에 전달할지 명시
    proxy_pass http://hostname:port;
    proxy_pass http://unix:/path/to/file.socket;
    proxy_pass http://upstreamname;

}
